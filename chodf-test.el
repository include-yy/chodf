;; -*- lexical-binding: t; -*-

(require 'ert)

(ert-deftest chodf-basic-t ()
  (should (= (chodf-ok 1) 1))
  (should (= (chodf-ok 2) 2))
  (should (eq (chodf-ok t) t))
  (should-error (chodf-ng '(error 1)) :type '(error))
  (should (equal '(error . 3)
		 (condition-case err
		     (chodf-ng '(error . 3))
		   (error err)))))

(ert-deftest chodf-struct-t ()
  (let ((ds (chodf-new :okcb 1 :ngcb 2 :n 3)))
    (should (= (chodf-okcb ds) 1))
    (should (= (chodf-ngcb ds) 2))
    (should (= (chodf-n ds) 3))
    (chodf--post ds :ok 4)
    (should (= (chodf-okcb (chodf-n ds)) 4))
    (chodf--post ds :ng 5)
    (should (= (chodf-ngcb (chodf-n ds)) 5))
    (chodf-next ds 6)
    (should (= (chodf-okcb (chodf-n ds)) 6))
    (chodf-error ds 7)
    (should (= (chodf-ngcb (chodf-n ds)) 7))
    (chodf-ner ds 8 9)
    (should (and (= (chodf-okcb (chodf-n ds)) 8)
		 (= (chodf-ngcb (chodf-n ds)) 9)))))

(ert-deftest chodf-fire-t ()
  (let ((f (lambda (n)
	     (let ((d (chodf-new)))
	       (run-at-time 0.05 nil
			    (lambda ()
			      (chodf-call d (1+ n))))
	       d)))
	(g (lambda (n)
	     (let ((d (chodf-new)))
	       (run-at-time 0.05 nil
			    (lambda ()
			      (chodf-fail d `(error . ,(1+ n)))))
	       d))))
    (let ((d (chodf-new))
	  (val 0))
      (setf (chodf-okcb d) (lambda (x) (setq val (1+ x))))
      (should (= (progn (chodf--fire d :ok 1) val) 2))
      (let ((it d))
	(setq it (chodf-next it (lambda (x) (setq val (+ x 2)))))
	(should (= (progn (chodf--fire d :ok 1) val) 4))
	(setq it (chodf-next it (lambda (x) (chodf-ng `(error . ,(1- x))))))
	(setq it (chodf-error it (lambda (x) (setq val (cdr x)))))
	(should (= (progn (chodf--fire d :ok 1) val) 3))
	(should (= (progn (chodf--fire d :ng '(error . 1)) val) 1))
	(let ((debug-on-error nil))
	  (should-error (chodf--fire d :hello 1) :type '(cl-assertion-failed)))))

    (let ((it (chodf-nextx (lambda (_) (1+ 1)))))
      (setq it (chodf-next it '1+))
      (setq it (chodf-next it '1+))
      (should (= (chodf-sync! it) 4)))

    (let ((it (chodf-nextx (lambda (_) (funcall f 1)))))
      (setq it (chodf-next it f))
      (setq it (chodf-next it (lambda (x) (* x 2))))
      (should (= (chodf-sync! it) 6)))

    (let ((it (chodf-callx f 1)))
      (should (= (chodf-sync! it) 2)))

    (let ((it (chodf-callx g 1)))
      (should (= (cdr (should-error (chodf-sync! it))) 2)))))

(ert-deftest chodf-wait-t ()
  (let ((it (chodf-wait 0.5)))
    (should (< (abs (- (chodf-sync! it) 0.5)) 0.1))))

(ert-deftest chodf-connect-t ()
  (let ((f (lambda (x cb)
	     (run-at-time 0.05 nil
			  (lambda ()
			    (funcall cb x))))))
    (let ((f1 (chodf-connect f)))
      (should (= (chodf-sync! (chodf-callx f1 1)) 1)))
    (let ((f2 (chodf-connect f 'cl-oddp)))
      (should (= (cdr (should-error (chodf-sync! (chodf-callx f2 2)))) 2))
      (should (= (chodf-sync! (chodf-callx f2 1)) 1)))
    (let ((f3 (chodf-connect f 'cl-oddp 'arith-error)))
      (should (= (chodf-sync! (chodf-callx f3 1)) 1))
      (should (equal (should-error (chodf-sync! (chodf-callx f3 2)))
		     '(arith-error . 2))))))

(ert-deftest chodf-parallel-t ()
  (let ((f (lambda (n)
	     (let ((d (chodf-new)))
	       (run-at-time 0.05 nil
			    (lambda ()
			      (chodf-call d (1+ n))))
	       d))))
    (let ((it (chodf-parallel
	       (funcall f 1)
	       (funcall f 2)
	       (funcall f 3)
	       (funcall f 4))))
      (should (let ((res (chodf-sync! it)))
		(and (= 2 (aref res 0))
		     (= 3 (aref res 1))
		     (= 4 (aref res 2))
		     (= 5 (aref res 3))))))
    (let ((g (let ((d (chodf-new)))
	       (run-at-time 0.05 nil
			    (lambda ()
			      (chodf-fail d '(error . 1))))
	       d)))
      (let ((it (chodf-parallel
		 (funcall f 1)
		 (funcall f 2)
		 (funcall f 3)
		 g)))
	(should (= (cdr (should-error (chodf-sync! it))) 1))))))


(ert-deftest chodf-chain-t ()
  (let ((f (lambda (n)
	     (let ((d (chodf-new)))
	       (run-at-time 0.05 nil
			    (lambda ()
			      (chodf-call d (1+ n))))
	       d)))
	(g (lambda (n)
	     (let ((d (chodf-new)))
	       (run-at-time 0.05 nil
			    (lambda ()
			      (chodf-fail d `(error . ,(1+ n)))))
	       d))))
    (let ((it (chodf-chain (lambda (_) (funcall f 1)) f f f f)))
      (should (= (chodf-sync! it) 6)))
    (let ((it (chodf-chain (lambda (_) (funcall f 1)) g f f f)))
      (should (= 3 (cdr (should-error (chodf-sync! it) :type '(error))))))
    (let ((it (chodf-chain (lambda (_) (funcall f 1))
			   g :err (lambda (x) (chodf-ng `(,(car x) . ,(- (cdr x) 2))))
			   f f f)))
      (should (= 1 (cdr (should-error (chodf-sync! it) :type '(error))))))
    (let ((it (chodf-chain (lambda (_) (funcall f 1))
			   g :err (lambda (x) (chodf-ng `(,(car x) . ,(- (cdr x) 2))))
			   :err (lambda (x) (+ (cdr x) 2))
			   f f f)))
      (should (= (chodf-sync! it) 6)))))

(ert-deftest chodf-earlier-t ()
  (let ((makef (lambda (time)
		 (lambda (n)
		   (let ((d (chodf-new)))
		     (run-at-time time nil
				  (lambda ()
				    (chodf-call d (1+ n))))
		     d))))
	(g (lambda (n)
	     (let ((d (chodf-new)))
	       (run-at-time 0 nil
			    (lambda ()
			      (chodf-fail d `(error . ,(1+ n)))))
	       d))))
    (let ((f1 (funcall makef 0.01))
	  (f2 (funcall makef 0.02))
	  (f3 (funcall makef 0.03)))
      (let ((it (chodf-earlier (funcall f1 1)
			       (funcall f2 2)
			       (funcall f3 3))))
	(should (equal '(0 . 2) (chodf-sync! it))))
      (let ((it (chodf-earlier (funcall f2 5)
			       (funcall f1 4)
			       (funcall f3 6))))
	(should (equal '(1 . 5) (chodf-sync! it))))
      (let ((it (chodf-earlier (funcall f1 0)
			       (funcall f2 1)
			       (funcall f3 2)
			       (funcall g  4))))
	(should (= (cdr (should-error (chodf-sync! it)
				      :type '(error)))
		   5))))))

(ert-deftest chodf-loop-t ()
  (let* ((a 0)
	 (f (lambda () (let ((d (chodf-new)))
			 (run-at-time
			  0.01 nil (lambda ()
				     (if (= (cl-incf a) 100)
					 (setq a "fin"))
				     (chodf-call d 1)))
			 d))))
    (chodf-sync! (chodf-loop 100 f))
    (should (string= a "fin")))
  (let* ((b 0)
	 (f (lambda () (cl-incf b))))
    (should (= (chodf-sync! (chodf-loop 100 f)) 100))))

(ert-deftest chodf-repeat-t ()
  (let ((f (lambda () (dotimes (_ 20000)))))
    (chodf-repeat 100 f)))

(ert-deftest chodf-retry-t ()
  (let* ((f (let ((i 0))
	      (lambda () (let ((d (chodf-new)))
			   (run-with-timer 0.001 nil
					   (lambda ()
					     (cl-incf i)
					     (if (< i 10)
						 (chodf-fail d `(error . 1))
					       (progn (setq i 0)
						      (chodf-call d t)))))
			   d))))
	 (it (chodf-retry 100 f 0.01)))
    (should (eq t (chodf-sync! it)))
    (setq it (chodf-retry 10 f 0.01))
    (should (eq t (chodf-sync! it)))
    (setq it (chodf-retry 9 f 0.01))
    (should (= (cdr (should-error (chodf-sync! it))) 1))))

;; strange zero argument call: (chodf-fail)
;; it won't signal an error or print "2" by the test above
;; (defun chodf-retry (cnt fun &optional wait)
;;   "Try func (returns Deferred) till it finish without exceptions.
;; If specified, WAIT is waiting time between each try, otherwise `chodf-ticktime'"
;;   (setq wait (or wait chodf-ticktime))
;;   (let ((d (chodf-new))
;; 	retry)
;;     (setq retry
;; 	  (lambda ()
;; 	    (let ((m (funcall fun)))
;; 	      (chodf-ner
;; 	       m (lambda (res)
;; 		   (chodf-call d res))
;; 	       (lambda (e)
;; 		 (print "opps")
;; 		 (if (<= (cl-decf cnt) 0)
;; 		     (progn (print e)
;; 			    (chodf-fail)
;; 			    (print "2"))
;; 		   (run-at-time wait nil retry)))))))
;;     (run-at-time 0 nil retry)
;;     d))
